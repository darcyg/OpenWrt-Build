1.Shell中变量的原形：${var}
大家常见的变量形式都是$var,如：
$ var=test 
$ echo $var 
test

但当你要显示变量值加随意的字符(我这里用AA)时，就会出错，如下：
$ echo $varAA

这时应该用变量的原形：${var}，即是加一个大括号来限定变量名称的范围，如下 
$ echo ${var}AA 
testAA 

以这个特性，我们可以很方便地写一个批量改后缀名的程序，我把它命名为mymv，程序如下： 
#!/bin/bash
tail=$1 
for filename in `ls` 
do 
	mv $filename ${filename}.$tail 
done

程序需要提供一个后缀名，如c，表示改为后缀为c的C程序文件，看下面的测试： 
$ ls 
a b c 
$ mymv c 
$ ls 
a.c b.c c.c 
$

看样子程序运行的很好，但这是不完善的程序，有2个要注意的问题：
A,目录下没有子目录，如果有一个目录，假设为dir，则也会被改为dir.c，这显然不是我们想要的，应该修正这个程序能识别目录。
B,没有帮助对程序的参数进行处理，程序应该足够友好，在用户没有给定后缀名时应能处理，像上面的将直接给文件加上了一个点(.),这显然也不是我们想要的。
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


2.命令替换$(cmd)
命令替换$(cmd)和符号`cmd`(注意这不是单引号，在美式键盘上，`是ESC下面的那个键)有相同之处 
$ ls 
a b c 
$ echo $(ls) 
a b c 
$ echo `ls` 
a b c

我们来分析一下命令echo $(ls)，以便理解所谓命令替换是什么意思：
shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令echo $(ls)中的$(ls)位置，即替换了$(ls),再执行echo命令。
如下：
echo $(ls)被替换成了echo a b c
这里要注意的是$(cmd)中的命令的错误输出是不会被替换的，替换的只是标准输出： 
$ var=$(cat d) ###文件d在当前目录不存在 
cat: d: 没有那个文件或目录 
$ echo $var

$ ###显然var变量的值是空的
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


3、一串的命令执行()和{}
()和{}都是对一串的命令进行执行，但有所区别：
A,()只是对一串命令重新开一个子shell进行执行
B,{}对一串命令在当前shell执行
C,()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开
D,()最后一个命令可以不用分号
E,{}最后一个命令要用分号
F,{}的第一个命令和左括号之间必须要有一个空格
G,()里的各命令不必和括号有空格
H,()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

我们来看几个例子： 
$ var=test 
$ (var=notest; echo $var) ###变量var值为notest，此是在子shell中有效 
notest 

$ echo $var ###父shell中值仍为test 
test 

$ { var=notest; echo $var;} ###注意左括号和var之间要有一个空格 
notest 
$ echo $var ###父shell中的var变量的值变为了notest 
notest 
$ { var1=test1;var2=test2;echo $var1>a;echo $var2;} ###输出test1被重定向到文件a中， 
test2 ###而test2输出则仍输出到标准输出中。 
$ cat a 
test1 
$ { var1=test1;var2=test2;echo $var1;echo $var2;}>a ###括号内命令的标准输出全部被重定向到文件a中 
$ cat a 
test1 
test2

下面是一个例子：
(
    echo "1"
    echo "2"
) | awk '{print NR,$0}'
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


5.POSIX标准的扩展计算:$((exp))
这种计算是符合C语言的运算符，也就是说只要符合C的运算符都可用在$((exp))，甚至是三目运算符。
注意：这种扩展计算是整数型的计算，不支持浮点型.若是逻辑判断，表达式exp为真则为1,假则为0。 
$ echo $((3+2)) 
5 
$ echo $((3>2)) 
1
$ echo $((25<3 ? 2:3)) 
3 
$ echo $var

$ echo $((var=2+3)) 
5 
$ echo $var 
5 
$ echo $((var++)) 
5 
$ echo $var 
6 
$

好了，上面的例子足够了，这也表明了这种扩展运算是很强大的。